<!doctype html>
<html>

<head>
  <meta charset="UTF-8" />
  <title>Potager</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser-ce@2.10.3/build/phaser.min.js"></script>
</head>

<body>
  <script src="js/PotaGen.js"></script>
  <script src="js/PotaTool.js"></script>
  <script type="text/javascript">
  "use strict";

  window.onload = function() {

    //  Note that this html file is set to pull down Phaser 2.5.0 from the JS Delivr CDN.
    //  Although it will work fine with this tutorial, it's almost certainly not the most current version.
    //  Be sure to replace it with an updated version before you start experimenting with adding your own code.

    const TARGET_WIDTH = Math.floor(1920 / 2 * 0.9);

    const CELL_SIZE = 32;

    const HUD_CELL_SIZE = 64;

    const ASPECT_RATIO = 16 / 10;

    const COLS = Math.floor(TARGET_WIDTH / CELL_SIZE);
    const LIGS = Math.floor(COLS / ASPECT_RATIO);

    var potaGen = new PotaGen(COLS, LIGS);

    var potaTool = new PotaTool(potaGen, { x: 5, y: 5 });

    console.log(potaGen.getContent(0, 0));

    const HUD_COLS = Math.floor(TARGET_WIDTH / HUD_CELL_SIZE);
    const HUD_LIGS = Math.floor(HUD_COLS / ASPECT_RATIO);

    var width = COLS * CELL_SIZE;
    var height = LIGS * CELL_SIZE;

    console.log("COLS : " + COLS);
    console.log("LIGS : " + LIGS);

    var cell = { type: 0 };

    var gameGrid = [];

    for (let lig = 0; lig < LIGS; ++lig) {

      gameGrid.push([]);

      for (let col = 0; col < COLS; ++col) {

        gameGrid[lig].push(cell);

      }

    }

    var game = new Phaser.Game(width, height, Phaser.AUTO, '', { preload: preload, create: create, update: update });

    var lastTime;

    function preload() {


      game.canvas.oncontextmenu = function(e) { e.preventDefault(); }

      game.load.spritesheet('ground_32x32', 'assets/TileSet.png', 32, 32);
      game.load.image('tools_64x64', 'assets/farm_tool_icons_calciumtrice.png');

      game.load.spritesheet('pepper', 'assets/Pepper.png', 24, 32);

    }

    var map;
    var toolsMap;
    var layer1;
    var layer2;
    var playerLayer;
    var hudLayer;
    var pepper;
    var marker;

    function create() {

      game.world.setBounds(-width / 2, -height / 2, width * 2, height * 2);


      /**
       *
       *  A TileSprite is a Sprite that has a repeating texture.
       *  The texture can be scrolled and scaled independently of the TileSprite itself.
       *  Textures will automatically wrap and are designed so that you can create game
       *  backdrops using seamless textures as a source.
       *
       **/
      // Create a tilesprite (x, y, width, height, key)
      game.add.tileSprite(-width / 2, -height / 2, width * 2, height * 2, 'ground_32x32', 12);

      //  Creates a blank tilemap
      map = game.add.tilemap();

      toolsMap = game.add.tilemap(null, HUD_CELL_SIZE, HUD_CELL_SIZE);

      //  Add a Tileset image to the map
      map.addTilesetImage('ground_32x32');
      toolsMap.addTilesetImage('tools_64x64');

      //  Creates a new blank layer and sets the map dimensions.
      //  In this case the map is COLS x LIGS tiles in size and the tiles are CELL_SIZE x CELL_SIZE pixels in size.
      layer1 = map.create('level1', COLS, LIGS, CELL_SIZE, CELL_SIZE);

      //  Our painting marker

      marker = game.add.graphics();
      marker.lineStyle(2, 0x000000, 1);
      marker.drawRect(0, 0, 32, 32);

      game.input.addMoveCallback(updateMarker, this);


      map.fill(0, 0, 0, COLS, LIGS);

      for (let i = 0; i < COLS; ++i) {

        map.putTile(60, i, LIGS - 1, layer1);
        map.putTile(60, i, 0, layer1);

      }

      for (let i = 0; i < LIGS; ++i) {

        map.putTile(61, 0, i, layer1);
        map.putTile(61, COLS - 1, i, layer1);

      }

      for (let i = 1; i < COLS-1; ++i) {

        map.putTile(2, i, LIGS - 2, layer1);
        map.putTile(3, i, 1, layer1);

      }

      for (let i = 1; i < LIGS-1; ++i) {

        map.putTile(4, 1, i, layer1);
        map.putTile(5, COLS - 2, i, layer1);

      }

      for (let i = 0; i < 2; ++i) {
        for (let j = 0; j < 2; ++j) {

          map.putTile(i * 2 + j + 6, (COLS - 3) * j+1, (LIGS - 2) - (LIGS - 3) * i, layer1);

          map.putTile(i * 2 + j + 62, (COLS - 1) * j, (LIGS-1)*i, layer1);

        }
      }

      layer2 = map.createBlankLayer('level2', COLS, LIGS, CELL_SIZE, CELL_SIZE);

      playerLayer = map.createBlankLayer('playerLayer', COLS, LIGS, CELL_SIZE, CELL_SIZE);

      hudLayer = toolsMap.create('hud', HUD_COLS, HUD_LIGS, HUD_CELL_SIZE, HUD_CELL_SIZE);

      toolsMap.putTile(2, Math.floor(HUD_COLS / 2), HUD_LIGS - 1, hudLayer);

      pepper = game.add.sprite(potaTool.playerPosition.x * CELL_SIZE, potaTool.playerPosition.y * CELL_SIZE, 'pepper');

      game.camera.follow(pepper);

      pepper.scale.set(2);
      pepper.smoothed = false;

      pepper.animations.add('walk_up', [0, 1, 2]);
      pepper.animations.add('walk_right', [3, 4, 5]);
      pepper.animations.add('walk_left', [9, 10, 11]);
      pepper.animations.add('walk_down', [6, 7, 8]);

      lastTime = game.time.elapsedSecondsSince(0);

      // game.add.sprite(0, 0, game.create.grid('grid', width, height, CELL_SIZE, CELL_SIZE, 'rgba(0, 250, 0, 1)'));

    }

    function updateMarker() {

      marker.x = layer1.getTileX(game.input.activePointer.worldX) * 32;
      marker.y = layer1.getTileY(game.input.activePointer.worldY) * 32;

      if (game.input.activePointer.leftButton.isDown) {

        console.log('left click');
        map.putTile(1, layer2.getTileX(marker.x), layer2.getTileY(marker.y), layer2);

      }

      if (game.input.activePointer.rightButton.isDown) {


        console.log('right click');
        map.removeTile(layer2.getTileX(marker.x), layer2.getTileY(marker.y), layer2);

      }

    }

    var directionKey = {

      isDown: false,
      direction: "",
      oldDirection: ""

    };

    function update() {

      // Check key states every frame.

      directionKey.direction = "";

      if (game.input.keyboard.isDown(Phaser.Keyboard.UP) ||
        game.input.keyboard.isDown(Phaser.Keyboard.Z)) {

        directionKey.direction = "up";

      } else if (game.input.keyboard.isDown(Phaser.Keyboard.LEFT) ||
        game.input.keyboard.isDown(Phaser.Keyboard.Q)) {

        directionKey.direction = "left";

      } else if (game.input.keyboard.isDown(Phaser.Keyboard.RIGHT) ||
        game.input.keyboard.isDown(Phaser.Keyboard.D)) {

        directionKey.direction = "right";

      } else if (game.input.keyboard.isDown(Phaser.Keyboard.DOWN) ||
        game.input.keyboard.isDown(Phaser.Keyboard.S)) {

        directionKey.direction = "down";

      }

      let newTime = game.time.elapsedSecondsSince(lastTime);
      potaTool.movePlayer(directionKey.direction, newTime - lastTime);
      lastTime = newTime;

      pepper.x = potaTool.playerPosition.x * CELL_SIZE;
      pepper.y = potaTool.playerPosition.y * CELL_SIZE;

      if ((!directionKey.isDown && directionKey.direction != "") ||
        directionKey.oldDirection != directionKey.direction) {

        directionKey.isDown = true;
        directionKey.oldDirection = directionKey.direction;

        pepper.animations.play('walk_' + directionKey.direction, 15, true);
        console.log("play");

      }

      if (directionKey.isDown && directionKey.direction == "") {

        directionKey.isDown = false;

        pepper.animations.stop();
        console.log("stop");

      }


    }

  };

  </script>
</body>

</html>

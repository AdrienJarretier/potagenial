<!doctype html>
<html>

<head>
  <meta charset="UTF-8" />
  <title>Potager</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser-ce@2.10.3/build/phaser.min.js"></script>
</head>

<body>
  <script src="js/PotaGen.js"></script>
  <script src="js/PotaTool.js"></script>
  <script type="text/javascript">
  "use strict";

  window.onload = function() {

    //  Note that this html file is set to pull down Phaser 2.5.0 from the JS Delivr CDN.
    //  Although it will work fine with this tutorial, it's almost certainly not the most current version.
    //  Be sure to replace it with an updated version before you start experimenting with adding your own code.

    const TARGET_WIDTH = Math.floor(1920 / 2 * 0.9);

    const CELL_SIZE = 32;

    const HUD_CELL_SIZE = 64;

    const ASPECT_RATIO = 16 / 9;

    const COLS = Math.floor(TARGET_WIDTH / CELL_SIZE);
    const LIGS = Math.floor(COLS / ASPECT_RATIO);

    var potaGen = new PotaGen(COLS, LIGS);

    var potaTool = new PotaTool(potaGen, { x: 5, y: 5 });

    // PotaKnow(potagen,potatool,(event) => {

    //     console.log('potagen modified');
    //     console.log(event);

    // },(str) => {

    //     console.log('say : ' + str);

    // },(str) => {

    //     console.log('task changed : ' + str);

    // });

    console.log(potaGen.getContent(0, 0));

    const HUD_COLS = Math.floor(TARGET_WIDTH / HUD_CELL_SIZE);
    const HUD_LIGS = Math.floor(HUD_COLS / ASPECT_RATIO);

    var width = COLS * CELL_SIZE;
    var height = LIGS * CELL_SIZE;

    console.log("COLS : " + COLS);
    console.log("LIGS : " + LIGS);

    var cell = { type: 0 };

    var gameGrid = [];

    for (let lig = 0; lig < LIGS; ++lig) {

      gameGrid.push([]);

      for (let col = 0; col < COLS; ++col) {

        gameGrid[lig].push(cell);

      }

    }

    var game = new Phaser.Game(width, height, Phaser.AUTO, '', { preload: preload, create: create, update: update });

    var lastTime = 0;


    // speed in pixel / sec
    const PLAYER_SPEED = 14 * CELL_SIZE;
    const CARROT_SPEED = 2 * CELL_SIZE;

    function preload() {


      game.canvas.oncontextmenu = function(e) { e.preventDefault(); }

      game.load.spritesheet('ground_32x32', 'assets/TileSet.png', 32, 32);
      game.load.image('tools_64x64', 'assets/farm_tool_icons_calciumtrice.png');

      game.load.spritesheet('pepper', 'assets/Pepper.png', 24, 32);
      game.load.spritesheet('carrot', 'assets/Carrot.png', 24, 32);

    }

    var map;
    var toolsMap;
    var layer1;
    var layer2;
    var playerLayer;
    var hudLayer;
    var pepper;
    var carrot;
    var marker;

    function create() {

      game.world.setBounds(-width / 2, -height / 2, width * 2, height * 2);


      /**
       *
       *  A TileSprite is a Sprite that has a repeating texture.
       *  The texture can be scrolled and scaled independently of the TileSprite itself.
       *  Textures will automatically wrap and are designed so that you can create game
       *  backdrops using seamless textures as a source.
       *
       **/
      // Create a tilesprite (x, y, width, height, key)
      game.add.tileSprite(-width / 2, -height / 2, width * 2, height * 2, 'ground_32x32', 12);

      //  Creates a blank tilemap
      map = game.add.tilemap();

      toolsMap = game.add.tilemap(null, HUD_CELL_SIZE, HUD_CELL_SIZE);

      //  Add a Tileset image to the map
      map.addTilesetImage('ground_32x32');
      toolsMap.addTilesetImage('tools_64x64');

      //  Creates a new blank layer and sets the map dimensions.
      //  In this case the map is COLS x LIGS tiles in size and the tiles are CELL_SIZE x CELL_SIZE pixels in size.
      layer1 = map.create('level1', COLS, LIGS, CELL_SIZE, CELL_SIZE);

      //  Our painting marker

      marker = game.add.graphics();
      marker.lineStyle(2, 0x000000, 1);
      marker.drawRect(0, 0, 32, 32);

      game.input.addMoveCallback(updateMarker, this);


      map.fill(0, 0, 0, COLS, LIGS);

      for (let i = 0; i < COLS; ++i) {

        map.putTile(60, i, LIGS - 1, layer1);
        map.putTile(60, i, 0, layer1);

      }

      for (let i = 0; i < LIGS; ++i) {

        map.putTile(61, 0, i, layer1);
        map.putTile(61, COLS - 1, i, layer1);

      }

      for (let i = 1; i < COLS - 1; ++i) {

        map.putTile(2, i, LIGS - 2, layer1);
        map.putTile(3, i, 1, layer1);

      }

      for (let i = 1; i < LIGS - 1; ++i) {

        map.putTile(4, 1, i, layer1);
        map.putTile(5, COLS - 2, i, layer1);

      }

      for (let i = 0; i < 2; ++i) {
        for (let j = 0; j < 2; ++j) {

          map.putTile(i * 2 + j + 6, (COLS - 3) * j + 1, (LIGS - 2) - (LIGS - 3) * i, layer1);

          map.putTile(i * 2 + j + 62, (COLS - 1) * j, (LIGS - 1) * i, layer1);

        }
      }

      layer2 = map.createBlankLayer('level2', COLS, LIGS, CELL_SIZE, CELL_SIZE);

      playerLayer = map.createBlankLayer('playerLayer', COLS, LIGS, CELL_SIZE, CELL_SIZE);

      hudLayer = toolsMap.create('hud', HUD_COLS, HUD_LIGS, HUD_CELL_SIZE, HUD_CELL_SIZE);

      toolsMap.putTile(2, Math.floor(HUD_COLS / 2), HUD_LIGS - 1, hudLayer);

      pepper = game.add.sprite(width / 2, height / 2, 'pepper');



      carrot = game.add.sprite(-CELL_SIZE, -CELL_SIZE, 'carrot');
      carrot.smoothed = false;
      carrot.scale.set(1.5);


      carrot.animations.add('walk_up', [0, 1, 2]);
      carrot.animations.add('walk_right', [3, 4, 5]);
      carrot.animations.add('walk_left', [9, 10, 11]);
      carrot.animations.add('walk_down', [6, 7, 8]);




      game.physics.enable(pepper, Phaser.Physics.arcade);

      game.physics.arcade.setBounds(CELL_SIZE / 2, 0, width - CELL_SIZE, height - CELL_SIZE);

      pepper.body.collideWorldBounds = true;


      //game.camera.follow(pepper);

      pepper.scale.set(2);
      pepper.smoothed = false;

      pepper.animations.add('walk_up', [0, 1, 2]);
      pepper.animations.add('walk_right', [3, 4, 5]);
      pepper.animations.add('walk_left', [9, 10, 11]);
      pepper.animations.add('walk_down', [6, 7, 8]);

      // game.add.sprite(0, 0, game.create.grid('grid', width, height, CELL_SIZE, CELL_SIZE, 'rgba(0, 250, 0, 1)'));

    }

    function updateMarker() {

      let tileX = layer1.getTileX(game.input.activePointer.worldX);
      let tileY = layer1.getTileY(game.input.activePointer.worldY);

      marker.x = tileX * 32;
      marker.y = tileY * 32;


      if (game.input.activePointer.leftButton.isDown) {

        let tileX = layer2.getTileX(marker.x);
        let tileY = layer2.getTileY(marker.y);

        map.putTile(1, tileX, tileY, layer2);

        // potaTool.use(tileX, tilesY, );

      }

      if (game.input.activePointer.rightButton.isDown) {

        map.removeTile(layer2.getTileX(marker.x), layer2.getTileY(marker.y), layer2);

      }

    }

    var directionKey = {

      isDown: false,
      direction: "",
      oldDirection: ""

    };



    let carrotVelocity = {

      x: 0,
      y: 0,
      direction: "",
      oldDirection: ""

    }

    function updateCarrot(elapsedSeconds) {

      if (carrot.y <= -CELL_SIZE) {

        carrotVelocity.x = CARROT_SPEED;
        carrotVelocity.y = 0;
        carrotVelocity.direction = 'right';

      }

      if (carrot.x >= width + CELL_SIZE) {

        carrotVelocity.x = 0;
        carrotVelocity.y = CARROT_SPEED;
        carrotVelocity.direction = 'down';

      }

      if (carrot.y >= height + CELL_SIZE) {

        carrotVelocity.x = -CARROT_SPEED;
        carrotVelocity.y = 0;
        carrotVelocity.direction = 'left';

      }

      if (carrot.x <= -CELL_SIZE && !(carrot.y <= -CELL_SIZE)) {

        carrotVelocity.x = 0;
        carrotVelocity.y = -CARROT_SPEED;
        carrotVelocity.direction = 'up';

      }


      if (carrotVelocity.oldDirection != carrotVelocity.direction) {

        console.log("carrot play " + 'walk_' + carrotVelocity.direction);
        carrotVelocity.oldDirection = carrotVelocity.direction;
        carrot.animations.play('walk_' + carrotVelocity.direction, 10, true);
      }

      // console.log(1/elapsedSeconds);

      carrot.x += carrotVelocity.x * elapsedSeconds;
      carrot.y += carrotVelocity.y * elapsedSeconds;

    }

    function update() {

      let newTime = game.time.totalElapsedSeconds(lastTime);

      let elapsedSeconds = newTime - lastTime;

      lastTime = newTime;

      updateCarrot(elapsedSeconds);

      // Check key states every frame.

      directionKey.direction = "";

      if (game.input.keyboard.isDown(Phaser.Keyboard.UP) ||
        game.input.keyboard.isDown(Phaser.Keyboard.Z)) {

        directionKey.direction = "up";

      } else if (game.input.keyboard.isDown(Phaser.Keyboard.LEFT) ||
        game.input.keyboard.isDown(Phaser.Keyboard.Q)) {

        directionKey.direction = "left";

      } else if (game.input.keyboard.isDown(Phaser.Keyboard.RIGHT) ||
        game.input.keyboard.isDown(Phaser.Keyboard.D)) {

        directionKey.direction = "right";

      } else if (game.input.keyboard.isDown(Phaser.Keyboard.DOWN) ||
        game.input.keyboard.isDown(Phaser.Keyboard.S)) {

        directionKey.direction = "down";

      }

      // pepper.x = potaTool.playerPosition.x * CELL_SIZE;
      // pepper.y = potaTool.playerPosition.y * CELL_SIZE;

      if ((!directionKey.isDown && directionKey.direction != "") ||
        directionKey.oldDirection != directionKey.direction) {

        directionKey.isDown = true;
        directionKey.oldDirection = directionKey.direction;

        pepper.animations.play('walk_' + directionKey.direction, 15, true);

      }

      if (directionKey.isDown && directionKey.direction == "") {

        directionKey.isDown = false;

        pepper.animations.stop();
      }

      setPlayerVelocity(directionKey.direction, elapsedSeconds);


    }

    function setPlayerVelocity(direction, elapsedSeconds) {

      pepper.body.velocity.x = 0;
      pepper.body.velocity.y = 0;

      let newSpeed = elapsedSeconds * PLAYER_SPEED * game.time.desiredFps;

      switch (direction) {
        case 'up':

          pepper.body.velocity.y = -newSpeed;

          break;
        case 'down':

          pepper.body.velocity.y = newSpeed;

          break;
        case 'left':

          pepper.body.velocity.x = -newSpeed;

          break;

        case 'right':

          pepper.body.velocity.x = newSpeed;

          break;
        default:

          break;
      }

    }

  };

  </script>
</body>

</html>
